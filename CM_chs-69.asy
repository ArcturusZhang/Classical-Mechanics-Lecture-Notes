if(!settings.multipleView) settings.batchView=false;
settings.tex="xelatex";
defaultfilename="CM_chs-69";
if(settings.render < 0) settings.render=4;
settings.outformat="";
settings.inlineimage=true;
settings.embed=true;
settings.toolbar=false;
viewportmargin=(2,2);

texpreamble("\usepackage{xeCJK}");
texpreamble("\setCJKmainfont{SimSun}");
usepackage("amsmath");
usepackage("amssymb");
size(350);
import graph;
import math;
//刚体定点转动的Euler角
real covert(pair x,real a){
if (x.x==0) return 90;
else return atan(a*x.y/x.x)*180/pi;
}
picture elpic1,tmp;
pair O1,O,x[],y[],z[];
real a,alpha1,alpha2,beta,gamma;
a = 2;
O1 = (0,0);
O = (0,0);
x[1] = (-a/sqrt(5),-a/sqrt(5));
y[1] = (a,0);
z[1] = (0,a);
//第一层
draw(elpic1,Label("$X$",EndPoint),O--x[1],blue,Arrow);
draw(elpic1,Label("$Y$",EndPoint),O--y[1],blue,Arrow);
draw(elpic1,Label("$Z$",EndPoint),O--z[1],blue,Arrow);
label(elpic1,"$O$",O,W);
path cir[],clp;
cir[1] = yscale(1/2)*scale(a)*unitcircle;
draw(elpic1,cir[1],blue);
alpha1 = 70;
alpha2 = 10;
real k;
k = tan(-alpha1*pi/180);
x[2] = (a/sqrt(1+4*k*k),a*k/sqrt(1+4*k*k));
k = tan(alpha2*pi/180);
y[2] = (a/sqrt(1+4*k*k),a*k/sqrt(1+4*k*k));
z[2] = z[1];
draw(elpic1,Label("$N$",EndPoint),-x[2]--x[2],Arrow);
draw(elpic1,Label("$L$",EndPoint),O--y[2],Arrow);
//第二层
picture elpic2;
beta = 35;
x[3] = x[2];
y[3] = rotate(beta)*y[1];
z[3] = rotate(0.9*beta)*z[1];
draw(elpic2,Label("$M$",EndPoint),O--y[3],Arrow);
draw(elpic2,Label("$z$",EndPoint),O--z[3],red,Arrow);
real k1,k2,ra,b;
k1 = -tan(alpha1*pi/180);
k2 = -tan((alpha1+beta)*pi/180);
ra = sqrt((1+4*k1^2)*(1+k2^2)/(1+k1^2)-1);
b = k2*a/ra;
cir[2] = rotate(beta)*yscale(b)*xscale(a)*unitcircle;
clp = 1.1*x[3]--1.1*x[3]+1.1*y[3]--(-1.1*x[3]+1.1*y[3])--(-1.1*x[3])--cycle;
draw(tmp,cir[2],red);
clip(tmp,clp);
add(elpic2,tmp);
erase(tmp);
draw(tmp,cir[2],red+dashed);
unfill(tmp,clp);
add(elpic2,tmp);
erase(tmp);
//第一层被第二层遮住的部分
unfill(elpic1,cir[2]);
draw(tmp,Label("$X$",EndPoint),O--x[1],blue+dashed,Arrow);
draw(tmp,Label("$Y$",EndPoint),O--y[1],blue+dashed,Arrow);
draw(tmp,Label("$Z$",EndPoint),O--z[1],blue,Arrow);
draw(tmp,Label("$N$",EndPoint),-x[2]--x[2],Arrow);
draw(tmp,Label("$L$",EndPoint),O--y[2],dashed,Arrow);
label(tmp,"$O$",O,W);
draw(tmp,cir[1],blue+dashed);
clip(tmp,cir[2]);
clip(tmp,clp);
add(elpic1,tmp);
erase(tmp);
draw(tmp,Label("$X$",EndPoint),O--x[1],blue,Arrow);
draw(tmp,Label("$Y$",EndPoint),O--y[1],blue,Arrow);
draw(tmp,Label("$Z$",EndPoint),O--z[1],blue,Arrow);
draw(tmp,Label("$N$",EndPoint),-x[2]--x[2],Arrow);
draw(tmp,Label("$L$",EndPoint),O--y[2],dashed,Arrow);
draw(tmp,Label("$Z$",EndPoint),O--z[2],dashed,Arrow);
label(tmp,"$O$",O,W);
draw(tmp,cir[1],blue);
clip(tmp,cir[2]);
unfill(tmp,clp);
add(elpic1,tmp);
erase(tmp);
//画自转
x[4] = relpoint(cir[2],0.78);
y[4] = relpoint(cir[2],0.05);
z[4] = z[3];
draw(elpic2,Label("$x$",EndPoint),O--x[4],red,Arrow);
draw(elpic2,Label("$y$",EndPoint),O--y[4],red,Arrow);
add(shift(O1)*elpic1);
add(shift(O1)*elpic2);
picture elpic4;
//画第一层上的角度
real theta1,theta2,r;
r = 0.4;
theta1 = covert(x[1],2)+180;
theta2 = covert(x[2],2)+360;
draw(elpic4,Label("$\phi$",MidPoint,Relative(E)),yscale(1/2)*arc(O,r,theta1,theta2),Arrow);
theta1 = covert(y[1],2);
theta2 = covert(y[2],2);
r = 0.7;
draw(elpic4,Label("$\phi$",MidPoint,E),yscale(1/2)*arc(O,r,theta1,theta2),Arrow);
//画第二层上的角度
r = 1.3;
theta1 = covert(y[2],0.9);
theta2 = covert(y[3],0.9);
draw(elpic4,Label("$\theta$",MidPoint,Relative(E)),xscale(0.9)*arc(O,r,theta1,theta2),Arrow);
theta1 = covert(z[2],0.9);
theta2 = covert(z[3],0.9);
draw(elpic4,Label("$\theta$",MidPoint,Relative(E)),xscale(0.9)*arc(O,r,theta1,180+theta2),Arrow);
//画自转角
r = 0.3;
//theta1 = covert(x[2],a/b);
//theta2 = covert(x[4],a/b);
draw(elpic4,Label("$\psi$",MidPoint,Relative(E)),arc(O,r,degrees(x[3]),degrees(x[4])),Arrow);
r = 0.4;
draw(elpic4,Label("$\psi$",MidPoint,Relative(E)),arc(O,r,degrees(y[3]),degrees(y[4])),Arrow);
add(shift(O1)*elpic4);
